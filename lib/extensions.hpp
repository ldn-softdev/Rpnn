/*
 * Created by Dmitry Lyssenko
 *
 * Macro definitions for declaring enums and auto-stringification:
 *
 * ENUM - will declare enum type w/o any possibility for stringification (mimics enum declaration)
 * ENUMSTR - will declare enum type and provide an array of c-strings representing enums
 * ENUMSTC - will declare enum type and static declaration (only) of array of c-strings
 * STRINGIFY - initialization (stringification) of previously declared enum type with ENUMSTC macro
 * STRENM - resolve enum c-string by enum value
 *
 * trivial macro definitions making enum stringification easy:
 * declare enums now in a few simple steps:
 *  1. define a macro enlisting all enum items:
 *
 *          #define MY_COLORS \
 *                  Red, \
 *                  Amber, \
 *                  Green
 *
 *  2. declare enums with ENUM, or ENUMSTR, or ENUMSTC marcos:
 *
 *          ENUMSTR(trafficLightColors, MY_COLORS)
 *
 *     - ENUM macro only declares trafficLightColors of enums (no stringification, mimic enum)
 *     - ENUMSTR in addition stringifies enums into: const char* trafficLightColors_str[] array
 *     - ENUMSTC only declares static const char* trafficLightColors_str[] array, so that later
 *               it could be initialized via STRINGIFY macro.
 *     ENUMSTC and STRINGIFY must be used in pair, when there's a need to define the array
 *     with stringified enums as **static**
 *
 *
 *  3. initialize an array of c-strings to generated by ENUMSTC macro (this step is redundant
 *     if ENUMSTR was used - there stringification occurs within the same macro):
 *
 *          STRINGIFY(SomeClass::trafficLightColors, MY_COLORS)
 *
 *          // or drop the class qualifier if declared not in class:
 *          STRINGIFY(trafficLightColors, MY_COLORS)
 *
 *  Now, enum trafficLightColors is defined, as well as its c-string representation:
 *
 *          std::cout << "All traffic-light colors:";
 *          for(int i = 0; i < COUNT_ARGS(MY_COLORS); ++i)
 *           cout << " "" << SomeClass::trafficLightColors_str[i];
 *           // or equally: cout << ' ' << STRENM(trafficLightColors, i);
 *          cout << endl;
 *
 * Obvious caveat: enums declared that way do not allow value re-definition
 * However, consider enum value redefinition a bad programming practice.
 * If so required, provide enum-remapping facility instead
 */

#pragma once
#include <string>
#include <vector>
#include <type_traits>
#include <mutex>
#include <tuple>
#include <functional>
#include "macrolib.hpp"



#define __COMMA_SEPARATED__(X) X,
#define __STR_COMMA_SEPARATED__(X) #X,


// declare enum from definition
#define ENUM(ENUM_CLASS, ENDEF...) \
    enum ENUM_CLASS { MACRO_TO_ARGS(__COMMA_SEPARATED__, ENDEF) };


// declare enum from definition & stringify
#define ENUMSTR(ENUM_CLASS, ENDEF...) \
    enum ENUM_CLASS { MACRO_TO_ARGS(__COMMA_SEPARATED__, ENDEF) }; \
    const char * ENUM_CLASS ## _str[COUNT_ARGS(ENDEF)] \
        { MACRO_TO_ARGS(__STR_COMMA_SEPARATED__, ENDEF) };


// declare enum from definition & declare static for STRINGIFY
#define ENUMSTC(ENUM_CLASS, ENDEF...) \
    enum ENUM_CLASS { MACRO_TO_ARGS(__COMMA_SEPARATED__, ENDEF) }; \
    static const char * ENUM_CLASS ## _str[];


// stringification for ENUMSTC
#define STRINGIFY(ENUM_CLASS, ENDEF...) \
    const char * ENUM_CLASS ## _str[] { MACRO_TO_ARGS(__STR_COMMA_SEPARATED__, ENDEF) };


// resolve c-string from enum index
#define STRENM(ENUM_CLASS, ENUM_IDX) ENUM_CLASS ## _str[ENUM_IDX]





/*
 * A trivial wrapper around std::exception
 * - to be used with enum stringification in classes (ENUMSTR, ENUMSTC)
 * - extends exception with following calls:
 *      func(): returns c-string of the function name (where exception occurred)
 *      file(): returns c-string of the file name holding the code where exceptions occurred
 *      line(): returns line number where exception occurs
 *      code(): returns integer of the exception (vs what() which returns c-string)
 *      where(): a combination of file(), func(), line() calls
 *
 * Synopsis:
 * // 1. define ENUMSTR (or ENUMSTC) within the class, enumerating exception reasons
 *
 *      class myClass {
 *       public:
 *        ...
 *          #define THROWREASON
 *              InvalidInput, \
 *              IncorrectUsage, \
 *              WrongType
 *          ENUMSTR(ThrowReason, THROWREASON)
 *          #undef THROWREASON
 *
 *          ...
 *          EXCEPTION(ThrowReason)
 *      };
 *
 *
 * // 2. use in throwing defined exception reasons, e.g.:
 *      throw EXP(InvalidInput);
 *
 *
 * // 3. Possible output upon non-handled exception:
 * libc++abi.dylib: terminating with uncaught exception of type myClass::stdException: InvalidInput
 *
 *
 * // 4. define catching exception:
 *      try { ... }     // something producing ThrowReason exception
 *      catch(myClass::stdException & e) {  // or std::exception & e, but then to access code()
 *                                          // and where() down-casting is required
 *       std::cout << "exception string: " << e.what() << std::endl;
 *       std::cout << "exception code: " << e.code() << std::endl;
 *       std::cout << "exception in: " << e.where() << std::endl;
 *      }
 *
 * Note: If exceptions code are meant to be used from a foreign class, e.g.:
 *       EXP(AnotherClass::ThrowReason::InvalidInput);
 *       then, in that class ThrowReason has to be declared using ENUMSTC, STRINGIFY and with
 *       public visibility, because this class needs to have an access to the stringified enum
 *       values
 */


// return std::exception from classes;
// upon throwing a copy of the object is made (throwing is by value). In our case
// a shallow copy will suffice despite the pointer: the class is meant to be used
// with ENUMSTR / STRINGIFY, which are static data.
// for in-class declaration:
#define EXCEPTIONS(THROW_ENUM) \
    class stdException: public std::exception { \
     public: \
                            stdException(void) = delete; \
                            stdException(int reason, const char *what, \
                                         const char *func, const char *file, int line): \
                             ec_{reason}, msg_{what}, func_{func}, file_{file}, line_{line} {} \
        const char *        what(void) const noexcept { return msg_; } \
        std::string         where(void) const noexcept { \
                             return std::string{"file: '"} + file_ + \
                                    "', func: '" + func_ + \
                                    "()', line: " + std::to_string(line_); \
                            } \
        const char *        func(void) const noexcept { return func_; } \
        const char *        file(void) const noexcept { return file_; } \
        int                 line(void) const noexcept { return line_; } \
        int                 code(void) const noexcept { return ec_; } \
     private: \
        int                 ec_; \
        const char *        msg_; \
        const char *        func_; \
        const char *        file_; \
        int                 line_; \
    }; \
    stdException __exp__(THROW_ENUM __reason__, const char *__funcname__, \
                         const char *__filename__, int __line__) const \
        { return stdException{__reason__, STRENM(THROW_ENUM, __reason__), \
                              __funcname__, __filename__, __line__}; }


// for in-place throw parameter
#define EXP(TROW_REASON) __exp__(TROW_REASON, __func__, __FILE__, __LINE__)





/*
 * Following trivial extension facilitates ability to check if a value is in
 * enumeration (similar to python's "x in [...]" construct)
 *
 * Synopsis:
 *
 *      x = 5;
 *      if(x AMONG(1,2,3,5,6))
 *       std::cout << "x is in!" << std::endl;
 *      else
 *       std::cout << "x is not in!" << std::endl;
 *
 *
 * CAVEAT on usage with c-strings:
 * - first parameter in AMONG macros to be type-casted as <const char*>:
 *
 *      const char *x = "abc";
 *      if(x AMONG(static_cast<const char*>("abc"), "def", "xyz")) ...
 *
 *
 * Preferably use AMONG construct, when number of enlisted arguments > 2, otherwise
 * go with conditional 'or'
 */

template<class T>
bool operator==(const T &__a__, std::initializer_list<T> && __v__) {
 for(auto &x: __v__)
  if(x == __a__) return true;
 return false;
}

bool operator==(const std::string &__a__, std::initializer_list<const char *> && __b__) {
 for(auto x: __b__)
  if(__a__ == x) return true;
 return false;
}

#define AMONG(FIRST, REST...) \
    == std::initializer_list<decltype(FIRST)>{FIRST, MACRO_TO_ARGS(__COMMA_SEPARATED__, REST)}





/*
 * GUARD is a polymorphic macro allowing stashing and automatically reinstating the
 * value of the preserved object accessed either by a reference, or via getters/setters
 *
 * 1. the following GUARD notation provides a guard functionality for an arbitrary object
 * accessible by reference: it will stash the object value upon interface declaration
 * and will restore the object value upon exiting the scope (GUARD's destruction);
 *
 * Synopsis:
 *      SomeClass x(3.14);                  // assuming SomeClass support copy/move constructors
 *      cout << "x: "  << x.get() << endl;
 *      {
 *       GUARD(x)                           // x will be COPIED upon stashing here
 *       // GUARD(std::move(x))             // alternatively: x will be MOVED upon stashing here
 *       x.set(2.71);
 *       cout << "x: "  << x.get() << endl;
 *      }                                   // x will be reinstated here via MOVE
 *      cout << "x: "  << x.get() << endl;
 *
 * Output:
 *      x: 3.14
 *      x: 2.71
 *      x: 3.14
 *
 *
 * 2. Sometimes classes cater only getter and setter methods to access
 * their elements. For such case, this GUARD notation provides a solution:
 *
 *      class MyX {
 *       public:
 *          SomeClass &         get(void) { return x_; }
 *          const SomeClass &   get(void) const { return x_; }
 *          void                set(int x) { x_ = x; }
 *          // alternative setter form:
 *          //  void                set(const int & x) { x_ = std::move(x); }
 *       private:
 *          SomeClass           x_;
 *      };
 *
 *      MyX x;
 *      x.set(123);
 *      cout << "x: "  << x.get() << endl;
 *      {
 *       GUARD(x.get(), x.set)              // object will be COPIED upon stashing
 *       // GUARD(std::move(x.get()), x.set)// alternatively: object will be MOVED upon stashing
 *       x.set(-1);
 *       // if GUARD(x.get(), x.set, -1) were used, then the object would get MOVED here upon
 *       // stashing (not copied) - no point to copy object if it gets immediately rewritten,
 *       // thus specifying `std::move(x.get())` would be redundant
 *       cout << "x: "  << x.get() << endl;
 *      }                                   // object will reinstated via MOVE (2 moves expected)
 *                                          // if alternative setter form was used, then object
 *                                          // would get reinstated via COPY (one copy expected)
 *      cout << "x: "  << x.get() << endl;
 *
 * Output:
 *      x: 123
 *      x: -1
 *      x: 123
 *
 *
 * in case where's multiple objects to guard, list them one by one each on the
 * new line:
 *      // ...
 *      GUARD(x)
 *      GUARD(y)
 *      // ...
 */


// There are 3 forms of GUARD: for a {single object}, form {object, setter}
// and form {object, setter, new_value}
// Forms demultiplexing occurs in __GUARD_CHOOSER__ macro, which results into
// expanding __GUARD_1_ARG__ for the former case and into __GUARD_2_ARG__ or
// __GUARD_3_ARG__
//
// __GUARD_1_ARG__: declares a trivial class __Guard_X__, which stores object's
// value and its pointer. Restoration of the object's value occurs upon __GUARD_X__'s
// destruction
//   o In this form, the argument is either moved or copied upon stashing when passed by
//     r-value or somehow else respectively.
//   o When restored, it's always moved
//
// __GUARD_2_ARG__:
//  - the first argument is the reference to the object itself (via getter call)
//      o in case of `l-value` reference, the object will be stashed via MOVE operation
//      o in case of `const l-value` reference, the object will be stashed via COPY
//      o in case of `r-value` reference, the object will be stashed via MOVE
//  - the second argument is the spelled setter call (e.g.: `x.set`) - the setter's call
//    is captured vial lambda calling the spelled setter upon the object restoration
//    (class destruction)
//      o if setter accepts its argument by `const l-value` reference then the restoration will
//        occur via COPY operation (which is not advisable for a setter)
//      o if setter accepts its argument by value, then copy-elision will ensure that
//        the value to setter will be passed via MOVE
//
// __GUARD_3_ARG__: just same as __GUARD_2_ARG__, just sets 3rd parameter (value) immediately
// via setter; 1st argument though is attempted to be MOVED (if getter permits)
//
// Each form of GUARD is appended __LINE__ macro to ensure uniqueness of declarations
// allowing  multiple invocations of the macro dodging name clashing

#define __STITCH_2TKNS__(X, Y) X ## Y
#define STITCH_2TKNS(X, Y) __STITCH_2TKNS__(X, Y)

// GUARD(X): where X is a reference to the guarded object
#define __GUARD_1_ARG__(X) \
    __Guard_X__<decltype(X)> STITCH_2TKNS(__my_Guard_X__, __LINE__)(X);


// GUARD(Y,Y): where X specifies a value/reference of the guarded object,
//             while Y only spells setter's call, e.g.: GUARD(obj.getter(), obj.setter)
#define __GUARD_2_ARG__(X, Y) \
    class STITCH_2TKNS(__Guard_GS__, __LINE__) { \
        typedef typename std::remove_const<std::remove_reference<decltype(X)>::type>::type Xtype; \
        Xtype x_; \
        std::function<void (Xtype &)> setter; \
     public: \
        /* constructor __Guard_X__ capturing by value (from getter()), and setter via lambda */ \
        STITCH_2TKNS(__Guard_GS__, __LINE__)(decltype(X) __Guard_X1__, \
                                             std::function<void(Xtype &)> &&__Guard_X2__): \
         x_(std::forward<decltype(X)>(__Guard_X1__)), \
         setter{std::move(__Guard_X2__)} {} /* capture lambda calling user setter */ \
        /* __Guard_X__ destructor calling the captured setter (target) */ \
       ~STITCH_2TKNS(__Guard_GS__, __LINE__)(void) \
         { setter(x_); }; /* reinstate via setter captured in lambda*/ \
    } STITCH_2TKNS(__my_Guard_GS__, __LINE__) \
        { X, [&](typename std::remove_const<std::remove_reference<decltype(X)>::type>::type & \
                          __Guard_ARG__) { Y(std::move(__Guard_ARG__)); } };

#define __GUARD_3_ARG__(X, Y, V) \
    __GUARD_2_ARG__(std::move(X), Y) \
    Y(V);

#define __GUARD_4TH_ARG__(ARG1, ARG2, ARG3, ARG4,...) ARG4
#define __GUARD_CHOOSER__(ARGS...) \
    __GUARD_4TH_ARG__(ARGS, __GUARD_3_ARG__, __GUARD_2_ARG__, __GUARD_1_ARG__)
#define GUARD(ARGS...) \
    __GUARD_CHOOSER__(ARGS)(ARGS)




template <typename T>
class __Guard_X__ {
 // Guard class - standalone usage
 public:
                        __Guard_X__(void) = delete;
                        // Do not try optimizing below two constructors into a single one with
                        // a copy elision (i.e., GUARD(typename <..> __Guard_X_arg__)) - that
                        // won't work because of the xptr_ - need to take address of the argument
                        // GUARD(x):
                        __Guard_X__(typename std::remove_reference<T>::type & __Guard_X_arg__):
                         x_{__Guard_X_arg__}, xptr_{&__Guard_X_arg__} {}
                        // GUARD(std::move(x)):
                        __Guard_X__(typename std::remove_reference<T>::type && __Guard_X_arg__):
                         x_{std::move(__Guard_X_arg__)}, xptr_{&__Guard_X_arg__} {}
                       ~__Guard_X__(void) { if(xptr_) *xptr_ = std::move(x_); }
 protected:
    typename std::remove_reference<T>::type     x_;
    typename std::remove_reference<T>::type *   xptr_;
};





/*
 * A trivial SWAP macro facilitating plain `void swap(left, right)` operation:
 *
 * Synopsis:
 * class my_class {
 *  friend SWAP(my_class, a_, b_, c_)
 *  ...
 * }
 *
 * The above translates into:
 * class my_class {
 *  friend void swap(my_class &left, my_class &right) {
 *   using std::swap;
 *   swap(left.a_, right.a_);
 *   swap(left.b_, right.b_);
 *   swap(left.c_, right.c_);
 *  }
 *  ...
 * }
 *
 *
 * Another COPY macro defying a copy for all enumerated elements: void copy(to, const from)
 * - similar to SWAP, but copies by value - to facilitate copying in non-default CC:
 *
 * Synopsis:
 * class my_class {
 *  COPY(my_class, a_, b_, c_)
 *                      my_class(const my_class &rhs)  {        // CC
 *                       copy(*this, rhs);
 *                       ...
 *                      }
 *  ...
 *  private:
 *      some_type        a_, b_, c_;
 * }
 *
 */

#define __SWAP_PAIR__(X) swap(__left__.X, __right__.X);

#define SWAP(TYPE, ARGS...) \
    void swap(TYPE &__left__, TYPE &__right__) \
     { using std::swap; MACRO_TO_ARGS(__SWAP_PAIR__, ARGS) }



#define __COPY_VAR__(X) __left__.X = __right__.X;

#define COPY(TYPE, ARGS...) \
    void copy(TYPE &__left__, const TYPE &__right__) \
     { MACRO_TO_ARGS(__COPY_VAR__, ARGS) }





/*
 * A couple of definitions for mutexes:
 * ULOCK - declare a unique_lock (mutex sguard)
 * TLOCK - declare an operator-like lock
 *
 * Synopsis:
 * {
 *  ULOCK(mtx)
 *  ...
 * } // mtx will be automatically released
 *
 * TLOCK(mtx) { // block is executed under mtx
 *  ...
 * }
 *
 */

#define ULOCK(MTX) \
    std::unique_lock<std::mutex> STITCH_2TKNS(__ulck__, __LINE__){MTX};

#define TLOCK(MTX) \
    for(std::unique_lock<std::mutex> __tlck__(MTX); __tlck__.owns_lock(); __tlck__.unlock())





/*
 * Sometimes, the code refactoring is required from within the loop, then it's required to
 * return flow control code like continue / break / return and none
 * - that simple enum defines those in Fc__:
 * Fc__::Break / Fc__::Continue / Fc__::Return / Fc__::None
 *
 * CBR polymorphic macro handles the return Fc__ codes and the return values as this:
 *
 * Synopsis:
 *  CBR(user_func(..))              // user_func() returns only Fc__, thus
 *                                  // Fc__::Return returns void
 * or,
 *  CBR(user_func(..))              // user_func() returns tuple<Fc__, ret_val_type>
 *                                  // Fc__::Return returns second value of tuple
 * or,
 *  CBR(user_func(..), ret_val)     // user_func() returns only Fc__, and
 *                                  // Fc__::Return returns rv
 *
 */


#define __FC__ \
            None, \
            Continue, \
            Break, \
            Return
ENUM(Fc__, __FC__)
#undef __FC__


Fc__ __Fctl_first__(Fc__ fc) { return fc; }
template<typename T>
T __Fctl_first__(const  std::tuple<Fc__, T> & tpl) { return std::get<0>(tpl); }

template<typename T>
T __Fctl_second__(const std::tuple<Fc__, T> & tpl) { return std::get<1>(tpl); }

#define __CBR_1_ARG__(RC) \
        auto const & __OPSRC__ = (RC); \
        if(__Fctl_first__(__OPSRC__) == Fc__::Continue) continue; \
        if(__Fctl_first__(__OPSRC__) == Fc__::Break) break; \
        if(__Fctl_first__(__OPSRC__) == Fc__::Return) return __Fctl_second__(__OPSRC__);
#define __CBR_2_ARG__(RC, RV) \
        auto const & __OPSRC__ = (RC); \
        if(__OPSRC__ == Fc__::Continue) continue; \
        if(__OPSRC__ == Fc__::Break) break; \
        if(__OPSRC__ == Fc__::Return) return RV;

#define __CBR_3RD_ARG__(ARG1, ARG2, ARG3, ...) ARG3
#define __CBR_CHOOSER__(ARGS...) \
    __CBR_3RD_ARG__(ARGS, __CBR_2_ARG__, __CBR_1_ARG__)
#define CBR(ARGS...) \
    __CBR_CHOOSER__(ARGS)(ARGS)
#define CNT_BRK_RTN(ARGS...) /* longer form of CBR macro */\
    __CBR_CHOOSER__(ARGS)(ARGS)












